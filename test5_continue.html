<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        ## 스택: 기본 자료형과 주소등을 저장하는 메모리 공간 
        ## 힙: 복합 자료형을 저장하는 메모리 공간
        ## 주소: 저장된 자료의 위치 
        ## 레퍼런스한다: 스택의 주소가 힙의 자료를 가리키는것
        ## 레퍼런스 읽어봐: 참조문서를 읽어봐
        ## 레퍼런스 변수: 지금 참조하고 있는 변수 / 포인터가 가리키는 변수 

        ### 질문1 ###
        스택에 있는 변수 c에는 배열의 주소(배열은 그 자체가 주소 지만)가 
        저장되어 있잖아 여기서 C언어는 포인터를 이용해 
        힙에 저장된 배열을 가리키는 건가? 

        ### 답변1 ###
        배열은 그 자체로 포인터(주소)이므로 
        포인터를 이용해 가리키고 있는 것이 
        아니라 배열을 가리키고 있다 가 맞음
        (주소는 스택에 들어간다)

        ### 참고 ###
        1. 배열의 메모리 할당
        배열이름 = 전체 배열의 주소 = 배열의 맨 앞칸의 주소
        2. 정수형 변수의 메모리 할당 
        변수는 주소에 위치함 
        변수의 주소를 알고싶다 >> 변수 앞에 &를 붙인다.

        ### 정리 ### 
        1. 저장을 할때 사용하는 공간 
        - stack 쌓는 공간 
        -> 기본 자료형 (숫자, 문자열, 불)은 그냥 저장됨
        -> 복합 자료형은 주소만 저장됨

        - heap 던져서 쌓는 공간
        -> 복합 자료형 (배열, 함수, 객체)의 본체가 저장됨

        2. 파괴 / 비파괴적
        -> 비파괴적 처리 : 어떠한 처리 후 원본이 변경되지 않는다 
        ### 비파괴적으로 동작하려면 원본, 새로운 생성본도 둘다 메모리에 존재
        -> 파괴적 처리 : 어떠한 처리 후 원본이 변경된다

        3. const의 제한
        const -> 스택에 있는 값 변경할때 오류
        힙에 있는 레퍼런스된 복합 자료형을 조작하는 것에는 문제가 없다.
        ex) b=[1,2]에서 b=[1,2,3,4] -> x / b.push(3,4) -> O
        
        */

       // 1. 파괴적처리 
       let c=[1,2,3]
       c.push(4)
       // 원본이 변경되었기 때문에 파괴적 처리다. 

       // 2. 비파괴적 처리 


        // continue , break
    </script>
</body>
</html>